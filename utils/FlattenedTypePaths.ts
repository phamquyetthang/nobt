import { DotNestedKeys } from './dotNestedKey';

/**
 * Generates a flattened representation of an object's type structure, mapping each nested path to its corresponding value type.
 * This utility type iterates over each key generated by `DotNestedKeys<T>` and resolves the type of the value at each nested path.
 * The resulting type is an object with keys in the format 'parent.child', each mapping to the type of the value at that path.
 *
 * @template T - The input object type to be flattened.
 * @example
 * // Given an object type:
 * const example = { foo: { bar: 123, baz: 456 } };
 *
 * // The resulting type would be:
 * type Result = FlattenedTypePaths<typeof example>;
 * // Expected type: {'foo.bar': number, 'foo.baz': number}
 */
export type FlattenedTypePaths<T> = {
  [P in DotNestedKeys<T>]: P extends `${infer Parent}.${infer Child}`
    ? Parent extends keyof T
      ? Child extends keyof T[Parent]
        ? T[Parent][Child]
        : never
      : never
    : never;
};

/**
 * Recursively generates a flattened representation of an object's type structure, mapping each nested path to its corresponding value type up to a specified depth.
 * This utility type iterates over each key in the object, and for objects at each level, it recursively applies itself to flatten the structure.
 * The depth parameter controls how deep the type should recurse into the object's structure, allowing for selective depth flattening.
 *
 * @template T - The input object type to be flattened.
 * @template Depth - A numeric literal type that specifies the maximum depth to flatten the object. A depth of 1 means no recursion.
 * @example
 * const example = {
 *   b: {
 *     c: 1,
 *     d: 2,
 *     e: {
 *       f: 1,
 *       g: {
 *         k: 10,
 *         l: '22',
 *       }
 *     }
 *   }
 * };
 *
 * // Flatten up to depth 2
 * type ResultDepth2 = DeepFlattenedTypePaths<typeof example, 2>;
 * // Expected type: { 'b.c': number, 'b.d': number, 'b.e': { f: number, g: { k: number, l: string } } }
 *
 * // Flatten up to depth 3
 * type ResultDepth3 = DeepFlattenedTypePaths<typeof example, 3>;
 * // Expected type: { 'b.c': number, 'b.d': number, 'b.e.f': number, 'b.e.g.k': number, 'b.e.g.l': string }
 */
export type DeepFlattenedTypePaths<T, Depth extends number> = Depth extends 0
  ? // eslint-disable-next-line @typescript-eslint/ban-types
    {}
  : {
      [K in keyof T]: T[K] extends object
        ? {
            [P in keyof DeepFlattenedTypePaths<
              T[K],
              Subtract<Depth>
            > as `${string & K}.${string & P}`]: DeepFlattenedTypePaths<
              T[K],
              Subtract<Depth>
            >[P];
          }
        : never;
    }[keyof T] &
      (Depth extends 1
        ? {
            [K in keyof T]: T[K];
          }
        : // eslint-disable-next-line @typescript-eslint/ban-types
          {});

type Subtract<N extends number> = N extends 1
  ? 0
  : N extends 2
    ? 1
    : N extends 3
      ? 2
      : N extends 4
        ? 3
        : N extends 5
          ? 4
          : N extends 6
            ? 5
            : N extends 7
              ? 6
              : N extends 8
                ? 7
                : N extends 9
                  ? 8
                  : N extends 10
                    ? 9
                    : never;
